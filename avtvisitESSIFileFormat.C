/*****************************************************************************
*
* Copyright (c) 2000 - 2013, Lawrence Livermore National Security, LLC
* Produced at the Lawrence Livermore National Laboratory
* LLNL-CODE-442911
* All rights reserved.
*
* This file is  part of VisIt. For  details, see https://visit.llnl.gov/.  The
* full copyright notice is contained in the file COPYRIGHT located at the root
* of the VisIt distribution or at http://www.llnl.gov/visit/copyright.html.
*
* Redistribution  and  use  in  source  and  binary  forms,  with  or  without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of  source code must  retain the above  copyright notice,
*    this list of conditions and the disclaimer below.
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this  list of  conditions  and  the  disclaimer (as noted below)  in  the
*    documentation and/or other materials provided with the distribution.
*  - Neither the name of  the LLNS/LLNL nor the names of  its contributors may
*    be used to endorse or promote products derived from this software without
*    specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT  HOLDERS AND CONTRIBUTORS "AS IS"
* AND ANY EXPRESS OR  IMPLIED WARRANTIES, INCLUDING,  BUT NOT  LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND  FITNESS FOR A PARTICULAR  PURPOSE
* ARE  DISCLAIMED. IN  NO EVENT  SHALL LAWRENCE  LIVERMORE NATIONAL  SECURITY,
* LLC, THE  U.S.  DEPARTMENT OF  ENERGY  OR  CONTRIBUTORS BE  LIABLE  FOR  ANY
* DIRECT,  INDIRECT,   INCIDENTAL,   SPECIAL,   EXEMPLARY,  OR   CONSEQUENTIAL
* DAMAGES (INCLUDING, BUT NOT  LIMITED TO, PROCUREMENT OF  SUBSTITUTE GOODS OR
* SERVICES; LOSS OF  USE, DATA, OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER
* CAUSED  AND  ON  ANY  THEORY  OF  LIABILITY,  WHETHER  IN  CONTRACT,  STRICT
* LIABILITY, OR TORT  (INCLUDING NEGLIGENCE OR OTHERWISE)  ARISING IN ANY  WAY
* OUT OF THE  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH
* DAMAGE.
*
*****************************************************************************/

// ************************************************************************* //
//                            avtvisitESSIFileFormat.C                           //
// ************************************************************************* //

#include <avtvisitESSIFileFormat.h>

#include <string>
#include <limits>

#include <vtkFloatArray.h>
#include <vtkIntArray.h>
#include <vtkPoints.h>
#include <vtkRectilinearGrid.h>
#include <vtkStructuredGrid.h>
#include <vtkUnstructuredGrid.h>

#include <avtDatabaseMetaData.h>
#include <avtIntervalTree.h>

#include <DBOptionsAttributes.h>
#include <Expression.h>

#include <InvalidVariableException.h>

#include <InvalidDBTypeException.h>

using     std::string;
#include <vtkCellType.h>

//For debugging (debug 4)
#include <DebugStream.h>


// My includes
#include <hdf5.h>

#define GO_HERE std::cout
// #define GO_HERE debug4

// ****************************************************************************
//  Method: avtvisitESSIFileFormat constructor
//
//  Programmer: jaabell -- generated by xml2avt
//  Creation:   Thu May 15 11:22:33 PDT 2014
//
// ****************************************************************************

avtvisitESSIFileFormat::avtvisitESSIFileFormat(const char *filename)
    : avtMTMDFileFormat(filename)
{
    // INITIALIZE DATA MEMBERS
    filename_string = filename;
    nnodes = 0;
    ncells = 0;
    nsteps = -1;

    returned_gaussmesh_already = false;
    returned_mainmesh_already = false;

    m_mainmesh_data = NULL;
    m_gaussmesh_data = NULL;

    initialized = false;
}




// ****************************************************************************
//  Method: avtvisitESSIFileFormat::FreeUpResources
//
//  Purpose:
//      When VisIt is done focusing on a particular timestep, it asks that
//      timestep to free up any resources (memory, file descriptors) that
//      it has associated with it.  This method is the mechanism for doing
//      that.
//
//  Programmer: jaabell -- generated by xml2avt
//  Creation:   Thu May 15 11:22:33 PDT 2014
//
// ****************************************************************************

void
avtvisitESSIFileFormat::FreeUpResources(void)
{
    // GO_HERE << "FREEEEE\n";
    // H5close();
    // if(m_gauss_to_element_tag[domain])
    // {
    //     delete [] m_gauss_to_element_tag[domain];
    //     m_gauss_to_element_tag[domain] = 0;
    // }
    // if(m_number_of_gauss_points[domain])
    // {
    //     delete [] m_number_of_gauss_points[domain];
    //     m_number_of_gauss_points[domain] = 0;
    // }
    // if(m_number_of_dofs[domain])
    // {
    //     delete [] m_number_of_dofs[domain];
    //     m_number_of_dofs[domain] = 0;
    // }
    // if(m_tags2pointnumbers[domain])
    // {
    //     delete [] m_tags2pointnumbers[domain];
    //     m_tags2pointnumbers[domain] = 0;
    // }
    // if(m_pointnumbers2tags[domain])
    // {
    //     delete [] m_pointnumbers2tags[domain];
    //     m_pointnumbers2tags[domain] = 0;
    // }
    // if(m_tags2cellnumbers[domain])
    // {
    //     delete [] m_tags2cellnumbers[domain];
    //     m_tags2cellnumbers[domain] = 0;
    // }
    // if(m_cellnumbers2tags[domain])
    // {
    //     delete [] m_cellnumbers2tags[domain];
    //     m_cellnumbers2tags[domain] = 0;
    // }
}


// ****************************************************************************
//  Method: avtvisitESSIFileFormat::PopulateDatabaseMetaData
//
//  Purpose:
//      This database meta-data object is like a table of contents for the
//      file.  By populating it, you are telling the rest of VisIt what
//      information it can request from you.
//
//  Programmer: jaabell -- generated by xml2avt
//  Creation:   Thu May 15 11:22:33 PDT 2014
//
// ****************************************************************************

void
avtvisitESSIFileFormat::PopulateDatabaseMetaData(avtDatabaseMetaData *md, int timeState)
{
    initialize();
    //
    // CODE TO ADD A MESH
    //
    //
    // AVT_RECTILINEAR_MESH, AVT_CURVILINEAR_MESH, AVT_UNSTRUCTURED_MESH,
    // AVT_POINT_MESH, AVT_SURFACE_MESH, AVT_UNKNOWN_MESH
    // avtMeshType mt = AVT_UNSTRUCTURED_MESH;
    // //
    // int nblocks = 1;//  <-- this must be 1 for MTSD
    // int block_origin = 0;
    // int spatial_dimension = 3;
    // int topological_dimension = 3;
    // double *extents = NULL;

    // // Here's the call that tells the meta-data object that we have a mesh:
    // //
    // AddMeshToMetaData(md, meshname, mt, extents, nblocks, block_origin,
    //                   spatial_dimension, topological_dimension);
    //

    mainmesh = "ESSI Domain Mesh";
    avtMeshMetaData *mmd = new avtMeshMetaData;
    mmd->name = mainmesh.c_str();
    mmd->spatialDimension = 3;
    mmd->topologicalDimension = 3;
    mmd->meshType = AVT_UNSTRUCTURED_MESH;
    mmd->numBlocks = number_of_processes > 1 ? number_of_processes - 1 : 1;

    md->Add(mmd);

    gaussmesh = "Gauss Points";
    mmd = new avtMeshMetaData;
    mmd->name = gaussmesh.c_str();
    mmd->spatialDimension = 3;
    mmd->topologicalDimension = 0;
    mmd->meshType = AVT_POINT_MESH;
    mmd->numBlocks = number_of_processes > 1 ? number_of_processes - 1 : 1;

    md->Add(mmd);

    GO_HERE << "ewmwecmwosmdcoiwemdeclkmsadlkmclkwqmdslkcmwdlksmcklds = " << number_of_processes << "\n";
    ncells = new int [number_of_processes];
    ngauss = new int [number_of_processes];
    nnodes = new int [number_of_processes];

    for (int i = 0; i < number_of_processes; i++)
    {
        ncells[i] = 0;
        ngauss[i] = 0;
        nnodes[i] = 0;
    }

    //
    // CODE TO ADD A SCALAR VARIABLE
    //
    string varname = "Node Tag";
    avtCentering cent = AVT_NODECENT;
    AddScalarVarToMetaData(md, varname, mainmesh, cent);


    varname = "Element Tag";
    cent = AVT_ZONECENT;
    AddScalarVarToMetaData(md, varname, mainmesh, cent);

    varname = "Element Partition";
    cent = AVT_ZONECENT;
    AddScalarVarToMetaData(md, varname, mainmesh, cent);

    varname = "Element Type";
    cent = AVT_ZONECENT;
    AddScalarVarToMetaData(md, varname, mainmesh, cent);

    varname = "8 Node Brick Update Time";
    cent = AVT_ZONECENT;
    AddScalarVarToMetaData(md, varname, mainmesh, cent);

    //
    // CODE TO ADD A VECTOR VARIABLE
    //
    varname = "Generalized Displacements";
    int vector_dim = 3;
    cent = AVT_NODECENT; // AVT_NODECENT, AVT_ZONECENT, AVT_UNKNOWN_CENT
    //
    //
    // Here's the call that tells the meta - data object that we have a var:
    //
    AddVectorVarToMetaData(md, varname, mainmesh, cent, vector_dim);
    //

    //
    // CODE TO ADD A TENSOR VARIABLE
    //
    varname = "Stress";
    int tensor_dim = 9;
    cent = AVT_NODECENT;
    AddTensorVarToMetaData(md, varname, gaussmesh, cent, tensor_dim);

    varname = "Strain";
    AddTensorVarToMetaData(md, varname, gaussmesh, cent, tensor_dim);

    varname = "Plastic Strain";
    AddTensorVarToMetaData(md, varname, gaussmesh, cent, tensor_dim);


    // CODE TO ADD A MATERIAL
    //
    // string mesh_for_mat = meshname; // ??? -- could be multiple meshes
    // string matname = ...
    // int nmats = ...;
    // vector<string> mnames;
    // for (int i = 0 ; i < nmats ; i++)
    // {
    //     char str[32];
    //     sprintf(str, "mat%d", i);
    //     -- or --
    //     strcpy(str, "Aluminum");
    //     mnames.push_back(str);
    // }
    //
    // Here's the call that tells the meta-data object that we have a mat:
    //
    // AddMaterialToMetaData(md, matname, mesh_for_mat, nmats, mnames);
    //
    //
    // Here's the way to add expressions:
    //Expression momentum_expr;
    //momentum_expr.SetName("momentum");
    //momentum_expr.SetDefinition("{u, v}");
    //momentum_expr.SetType(Expression::VectorMeshVar);
    //md->AddExpression(&momentum_expr);
    //Expression KineticEnergy_expr;
    //KineticEnergy_expr.SetName("KineticEnergy");
    //KineticEnergy_expr.SetDefinition("0.5*(momentum*momentum)/(rho*rho)");
    //KineticEnergy_expr.SetType(Expression::ScalarMeshVar);
    //md->AddExpression(&KineticEnergy_expr);
    //

    Expression *e1 = new Expression;
    e1->SetName("Sigma_X");
    e1->SetDefinition("Stress[0][0]");
    e1->SetType(Expression::ScalarMeshVar);
    e1->SetHidden(false);
    md->AddExpression(e1);

    Expression *e2 = new Expression;
    e2->SetName("Sigma_Y");
    e2->SetDefinition("Stress[1][1]");
    e2->SetType(Expression::ScalarMeshVar);
    e2->SetHidden(false);
    md->AddExpression(e2);

    Expression *e3 = new Expression;
    e3->SetName("Sigma_Z");
    e3->SetDefinition("Stress[2][2]");
    e3->SetType(Expression::ScalarMeshVar);
    e3->SetHidden(false);
    md->AddExpression(e3);

    Expression *e4 = new Expression;
    e4->SetName("Tau_XY");
    e4->SetDefinition("Stress[0][1]");
    e4->SetType(Expression::ScalarMeshVar);
    e4->SetHidden(false);
    md->AddExpression(e4);

    Expression *e5 = new Expression;
    e5->SetName("Tau_XZ");
    e5->SetDefinition("Stress[0][2]");
    e5->SetType(Expression::ScalarMeshVar);
    e5->SetHidden(false);
    md->AddExpression(e5);

    Expression *e6 = new Expression;
    e6->SetName("Tau_YZ");
    e6->SetDefinition("Stress[1][2]");
    e6->SetType(Expression::ScalarMeshVar);
    e6->SetHidden(false);
    md->AddExpression(e6);
}


// ****************************************************************************
//  Method: avtvisitESSIFileFormat::GetMesh
//
//  Purpose:
//      Gets the mesh associated with this file.  The mesh is returned as a
//      derived type of vtkDataSet (ie vtkRectilinearGrid, vtkStructuredGrid,
//      vtkUnstructuredGrid, etc).
//
//  Arguments:
//      timestate   The index of the timestate.  If GetNTimesteps returned
//                  'N' time steps, this is guaranteed to be between 0 and N-1.
//      domain      The index of the domain.  If there are NDomains, this
//                  value is guaranteed to be between 0 and NDomains-1,
//                  regardless of block origin.
//      meshname    The name of the mesh of interest.  This can be ignored if
//                  there is only one mesh.
//
//  Programmer: jaabell -- generated by xml2avt
//  Creation:   Thu May 15 11:22:33 PDT 2014
//
// ****************************************************************************

vtkDataSet *
avtvisitESSIFileFormat::GetMesh(int timestate, int domain, const char *meshname)
{
    initialize();
    GO_HERE << "visitESSI: Getting Mesh: -> " <<  meshname <<  ", domain = " << domain << "\n\n" ;
    // GO_HERE << "visitESSI: Getting Mesh: -> " <<  meshname <<  " domain = " << domain << "\n\n" ;

    // string mname = meshname;



    // =============================================================================================
    // =============================================================================================
    // =============================================================================================
    // =============================================================================================
    //   MAIN MESH
    // =============================================================================================
    // =============================================================================================
    // =============================================================================================
    // =============================================================================================
    // =============================================================================================
    openSubdomainNumber(domain);

    if (strcmp(meshname, mainmesh.c_str()) == 0 )
    {
        // If this is the first time reading the mesh data -> load it into memory!!
        if (m_mainmesh_data[domain] == NULL)
        {

            // nnodes[domain] = 0;

            int ndims  = 3;
            int origin = 0;
            // ncells[domain] = 0;
            herr_t status;

            // float *mainmesh_pts;
            int *connectivity;
            int *elements_nnodes;

            hsize_t id_elements_nnodes_nvals;

            //////////////////////////////////////////////////////////////////////////////////////////
            // Nodes
            //////////////////////////////////////////////////////////////////////////////////////////


            GO_HERE << "visitESSI: Reading Node Info for domain " << domain << "\n\n";


            //Get the number of defined nodes
            // Read number of elements
            hid_t id_num_elements = H5Dopen2(id_file, "/Number_of_Elements", H5P_DEFAULT);
            hid_t id_num_elements_dataspace = H5Dget_space(id_num_elements);
            H5Dread(id_num_elements, H5T_NATIVE_INT, H5S_ALL   , id_num_elements_dataspace, H5P_DEFAULT,
                    &ncells[domain]);
            H5Dclose(id_num_elements);
            H5Sclose(id_num_elements_dataspace);


            // Read number of nodes
            int numero_de_nodos;
            hid_t id_num_nodes = H5Dopen2(id_file, "/Number_of_Nodes", H5P_DEFAULT);
            hid_t id_num_nodes_dataspace = H5Dget_space(id_num_nodes);
            H5Dread(id_num_nodes, H5T_NATIVE_INT, H5S_ALL   , id_num_nodes_dataspace, H5P_DEFAULT,
                    &(nnodes[domain]));
            GO_HERE << "&nnodes[domain] = " << nnodes[domain] << endl;
            H5Dclose(id_num_nodes);
            H5Sclose(id_num_nodes_dataspace);

            hid_t id_nodes_coordinates                    = H5Dopen2(id_file, "/Model/Nodes/Coordinates", H5P_DEFAULT);
            hid_t id_coordinates_dataspace                = H5Dget_space(id_nodes_coordinates);
            hsize_t id_nodes_coordinates_nvals            = H5Sget_simple_extent_npoints(id_coordinates_dataspace);
            // nnodes[domain]                                        = static_cast<int> (id_nodes_coordinates_nvals) / 3;
            //Get number of maximum possibly defined tags :/
            hid_t id_nodes_index_to_coordinates           = H5Dopen2(id_file, "/Model/Nodes/Index_to_Coordinates", H5P_DEFAULT);
            hid_t id_nodes_index_to_coordinates_dataspace = H5Dget_space(id_nodes_index_to_coordinates);
            hsize_t nodes_number_of_tags_max              = H5Sget_simple_extent_npoints(id_nodes_index_to_coordinates_dataspace);

            //Get the index to coordinates
            int *index_to_coordinates = new int[nodes_number_of_tags_max];
            status = H5Dread(id_nodes_index_to_coordinates, H5T_NATIVE_INT, H5S_ALL   , id_nodes_index_to_coordinates_dataspace, H5P_DEFAULT,
                             index_to_coordinates);



            //Form an array that transforms node "tags" to connectivity indexes
            m_tags2pointnumbers[domain] = new int[nodes_number_of_tags_max];
            m_pointnumbers2tags[domain] = new int[nodes_number_of_tags_max];
            int point_number = 0;
            for (int tag = 0; tag < nodes_number_of_tags_max; tag++)
            {
                if (index_to_coordinates[tag] >= 0) // This condition checks that the node tag exists (else it has -1 in index to coord)
                {
                    point_number = index_to_coordinates[tag] / 3;
                    m_tags2pointnumbers[domain][tag] = point_number;
                    m_pointnumbers2tags[domain][point_number] = tag;
                    // point_number++;
                }
                else // tag does not exist so no corresponding point number is generated
                {
                    m_tags2pointnumbers[domain][tag] = -1;
                }
            }



            //Get number of DOFS
            hid_t id_nodes_number_of_dofs           = H5Dopen2(id_file, "/Model/Nodes/Number_of_DOFs", H5P_DEFAULT);
            hid_t id_nodes_number_of_dofs_dataspace = H5Dget_space(id_nodes_number_of_dofs);

            //Get the index to coordinates
            m_number_of_dofs[domain] = new int[nodes_number_of_tags_max];
            status = H5Dread(id_nodes_number_of_dofs, H5T_NATIVE_INT, H5S_ALL   , id_nodes_number_of_dofs_dataspace, H5P_DEFAULT,
                             m_number_of_dofs[domain]);





            //
            // Create the vtkPoints object and copy points into it.
            //
            vtkPoints *points = vtkPoints::New();
            points->SetNumberOfPoints(nnodes[domain]);
            float *pts        = (float *) points->GetVoidPointer(0);



            // mainmesh_pts = new float[nnodes * 3];

            //Read values of coordinates from HDF5 directly into the VTK pts pointer
            const hsize_t dims[1]          = {nnodes[domain] * 3};
            hid_t memspace                 = H5Screate_simple(1, dims, dims);
            status = H5Dread(id_nodes_coordinates,
                             H5T_NATIVE_FLOAT,
                             memspace,
                             id_coordinates_dataspace,
                             H5P_DEFAULT,
                             pts);
            // for (int nodenum = 0; nodenum < nnodes[domain]; nodenum++)
            // {
            //     GO_HERE << "(" << pts[nodenum] << " " << pts[nodenum] << " " << pts[nodenum] << ") ";
            // }
            GO_HERE << "visitESSI: Done reading nodes. Read " << nnodes << " nodes values.\n\n";

            //Free up memory.
            delete [] index_to_coordinates;
            H5Dclose(id_nodes_coordinates);
            H5Sclose(id_coordinates_dataspace);
            H5Dclose(id_nodes_index_to_coordinates);
            H5Sclose(id_nodes_index_to_coordinates_dataspace);


            //////////////////////////////////////////////////////////////////////////////////////////
            //    ELEMENTS
            //////////////////////////////////////////////////////////////////////////////////////////
            GO_HERE << "visitESSI: Reading Element Info\n\n";


            //Get the number of elements (ncells[domain])
            hid_t id_elements_nnodes = H5Dopen2(id_file, "/Model/Elements/Number_of_Nodes", H5P_DEFAULT);
            hid_t id_elements_nnodes_dataspace = H5Dget_space(id_elements_nnodes);
            id_elements_nnodes_nvals  = H5Sget_simple_extent_npoints(id_elements_nnodes_dataspace);

            max_ele_tag = id_elements_nnodes;

            elements_nnodes  = new int[id_elements_nnodes_nvals];
            status = H5Dread(id_elements_nnodes, H5T_NATIVE_INT, H5S_ALL   , id_elements_nnodes_dataspace, H5P_DEFAULT,
                             elements_nnodes);

            max_node_tag = id_elements_nnodes_nvals;

            m_tags2cellnumbers[domain] = new int[id_elements_nnodes_nvals];
            m_cellnumbers2tags[domain] = new int[id_elements_nnodes_nvals];
            int cellnumber = 0;
            for (int tag = 0; tag < id_elements_nnodes_nvals; tag++)
            {
                if (elements_nnodes[tag] >= 0) // This condition checks that the element tag exists (else it has -1 in number of nodes)
                {
                    m_tags2cellnumbers[domain][tag] = cellnumber;
                    m_cellnumbers2tags[domain][cellnumber] = tag;
                    cellnumber++;
                }
                else // tag does not exist so no corresponding cell number is generated
                {
                    m_tags2cellnumbers[domain][tag] = -1;
                }
            }


            H5Dclose(id_elements_nnodes);
            H5Sclose(id_elements_nnodes_dataspace);


            GO_HERE << "visitESSI: Mesh has " << ncells[domain] <<  " elements. \n\n";

            GO_HERE << "visitESSI: Reading connectivity \n\n";

            //Get the  connectivity
            hid_t id_elements_connectivity           = H5Dopen2(id_file, "/Model/Elements/Connectivity", H5P_DEFAULT);
            hid_t id_elements_connectivity_dataspace = H5Dget_space(id_elements_connectivity);
            hsize_t id_elements_connectivity_nvals   = H5Sget_simple_extent_npoints(id_elements_connectivity_dataspace);

            connectivity  = new int[id_elements_connectivity_nvals];
            status = H5Dread(id_elements_connectivity, H5T_NATIVE_INT, H5S_ALL   , id_elements_connectivity_dataspace, H5P_DEFAULT,
                             connectivity);
            H5Dclose(id_elements_connectivity);
            H5Sclose(id_elements_connectivity_dataspace);

            returned_mainmesh_already = true;

            GO_HERE << "visitESSI: Done! \n\n";


            GO_HERE << "visitESSI : Generating VTK nodes\n";


            //
            // Create a vtkUnstructuredGrid to contain the point cells.
            //
            m_mainmesh_data[domain] = vtkUnstructuredGrid::New();
            m_mainmesh_data[domain]  -> SetPoints(points);
            points -> Delete();
            m_mainmesh_data[domain]  -> Allocate(ncells[domain]);

            vtkIdType verts[27];



            // Converters from ESSI node conventions to VTK

            //                                 0  1  2  3  4  5  6  7
            int essi_to_vtk_point[1]        = { 0  };
            int essi_to_vtk_beam[2]         = { 0 , 1 };
            int essi_to_vtk_4nodeandes[4]   = { 0 , 1, 2, 3 };
            int essi_to_vtk_8nodebrick[8]   = {4, 5, 6, 7, 0, 1, 2, 3};
            //                                  0   1   2   3   4   5   6   7   8   9   10   11   12   13   14   15   16   17   18   19   20   21   22   23   24   25   26
            int essi_to_vtk_27nodebrick[27] = { 6,  5,  4,  7,  2,  1,  0,  3,  13, 12, 15,  14,   9,   8,  11,  10,  18,  17,  16,  19,  23,  21,  22,  24,  26,  25,  20 };


            //Loop over elements and add them
            int count = 0;
            int number_of_added_elements = 0;
            int *access_order;
            bool found = false;

            for (int tag = 0; tag < id_elements_nnodes_nvals; tag++)
            {
                int cellType = 0;
                int nverts = 0;
                found = false;

                if (elements_nnodes[tag] > 0)
                {

                    nverts = elements_nnodes[tag];
                    number_of_added_elements++;
                    if (nverts == 1)
                    {
                        // nverts = 1;
                        cellType = VTK_VERTEX;
                        access_order = essi_to_vtk_point;
                        found = true;
                    }
                    else if (nverts == 2)
                    {
                        // nverts = 2;
                        cellType = VTK_LINE;
                        access_order = essi_to_vtk_beam;
                        found = true;
                    }
                    else if (nverts == 4)
                    {
                        // nverts = 4;
                        cellType = VTK_QUAD;
                        access_order = essi_to_vtk_4nodeandes;
                        found = true;
                    }
                    else if (nverts == 8)
                    {
                        cellType = VTK_HEXAHEDRON;
                        access_order = essi_to_vtk_8nodebrick;
                        found = true;
                    }
                    else if (nverts == 27)
                    {
                        // nverts = 27;
                        cellType = VTK_TRIQUADRATIC_HEXAHEDRON;
                        access_order = essi_to_vtk_27nodebrick;
                        found = true;
                    }
                    if (found)
                    {
                        // Make a list of node indices that make up the cell..
                        int essi_node_number;
                        int visit_vertex_number;
                        for (int j = 0; j < nverts; j++)
                        {
                            essi_node_number = connectivity[count + access_order[j]];
                            visit_vertex_number = m_tags2pointnumbers[domain][essi_node_number];

                            if (visit_vertex_number >= 0)
                            {
                                verts[j] = visit_vertex_number;
                            }
                            else
                            {
                                //Something went wrong
                                GO_HERE << "!!!! visitESSI - something went wrong\n\n";
                                // EXCEPTION0(InvalidVariableException, meshname);
                            }
                        }
                        m_mainmesh_data[domain]->InsertNextCell(cellType, nverts, verts);
                    }
                    count += nverts;
                }
            }
            // GO_HERE << "visitESSI: Added " << number_of_added_elements << " elements of " << ncells[domain] << " total available.\n\n";
            GO_HERE << "visitESSI: Added " << number_of_added_elements << " elements of " << ncells[domain] << " total available.\n\n";
        }

        m_mainmesh_data[domain]->Register(NULL);
        return m_mainmesh_data[domain];
    }   //Ends Brick Elements Mesh





    // =============================================================================================
    // =============================================================================================
    // =============================================================================================
    // =============================================================================================
    //   GAUSS POINT MESH
    // =============================================================================================
    // =============================================================================================
    // =============================================================================================
    // =============================================================================================
    // =============================================================================================


    else if (strcmp(meshname, gaussmesh.c_str()) == 0)
    {
        if (m_gaussmesh_data[domain] == NULL)
        {
            int ndims  = 3;
            int origin = 0;
            herr_t status;


            GO_HERE << "visitESSI: Reading GP Info\n\n";

            //Get the number of defined gausspoints
            hid_t id_gausspoints_coordinates                    = H5Dopen2(id_file, "/Model/Elements/Gauss_Point_Coordinates", H5P_DEFAULT);
            hid_t id_coordinates_dataspace                = H5Dget_space(id_gausspoints_coordinates);
            hsize_t id_gausspoints_coordinates_nvals            = H5Sget_simple_extent_npoints(id_coordinates_dataspace);
            // ngauss                                        = static_cast<int> (id_gausspoints_coordinates_nvals) / 3;


            //Get number of maximum possibly defined tags :/
            hid_t id_gausspoints_index_to_coordinates           = H5Dopen2(id_file, "/Model/Elements/Index_to_Gauss_Point_Coordinates", H5P_DEFAULT);
            hid_t id_gausspoints_index_to_coordinates_dataspace = H5Dget_space(id_gausspoints_index_to_coordinates);
            hsize_t gausspoints_number_of_tags_max              = H5Sget_simple_extent_npoints(id_gausspoints_index_to_coordinates_dataspace);

            //Get the index to coordinates of GPS
            int *index_to_coordinates = new int[gausspoints_number_of_tags_max];
            status = H5Dread(id_gausspoints_index_to_coordinates, H5T_NATIVE_INT, H5S_ALL   , id_gausspoints_index_to_coordinates_dataspace, H5P_DEFAULT,
                             index_to_coordinates);

            //Get number of Gauss points per element
            hid_t id_number_of_gausspoints           = H5Dopen2(id_file, "/Model/Elements/Number_of_Gauss_Points", H5P_DEFAULT);
            hid_t id_number_of_gausspoints_dataspace = H5Dget_space(id_number_of_gausspoints);


            //Get the number of GPs
            m_number_of_gauss_points[domain] = new int[gausspoints_number_of_tags_max];
            status = H5Dread(id_number_of_gausspoints, H5T_NATIVE_INT, H5S_ALL   , id_number_of_gausspoints_dataspace, H5P_DEFAULT,
                             m_number_of_gauss_points[domain]);


            ngauss[domain] = 0;
            for (int tag = 0; tag < gausspoints_number_of_tags_max; tag++)
            {
                if (index_to_coordinates[tag] >= 0)
                {
                    ngauss[domain] += m_number_of_gauss_points[domain][tag];
                }
            }

            GO_HERE << " Number of GPs on domain #" << domain << " = " << ngauss[domain] << endl;

            //Build an index that relates number of a gauss point to the element it belongs to
            // m_gauss_to_element_tag[domain] = new int[ngauss[domain]];
            // int gaussnumber = 0;
            // for (int tag = 0; tag < gausspoints_number_of_tags_max; tag++)
            // {
            //     if (index_to_coordinates[tag] >= 0)
            //     {
            //         int number_of_gauss_points_for_this_element;
            //         number_of_gauss_points_for_this_element = m_number_of_gauss_points[domain][tag];
            //         for (int g = 0; g < number_of_gauss_points_for_this_element; g++)
            //         {
            //             m_gauss_to_element_tag[domain][gaussnumber] = tag;
            //             gaussnumber++;
            //         }
            //     }
            // }


            // Write the gausspoints
            vtkPoints *points = vtkPoints::New();

            points->SetNumberOfPoints(ngauss[domain]);
            float *pts        = (float *) points->GetVoidPointer(0);

            //Read values of coordinates from HDF5 directly into the VTK pts pointer
            const hsize_t dims[1]          = {ngauss[domain] * 3 };
            hid_t memspace                 = H5Screate_simple(1, dims, dims);
            hsize_t start[1] = {0};
            hsize_t stride[1] = {1};
            hsize_t count[1] = {3 * ngauss[domain]};
            hsize_t block[1] = {1};
            status =  H5Sselect_hyperslab(id_coordinates_dataspace, H5S_SELECT_SET,  start,  stride,  count,  block );
            status = H5Dread(id_gausspoints_coordinates, H5T_NATIVE_FLOAT, memspace, id_coordinates_dataspace, H5P_DEFAULT,
                             pts);

            GO_HERE << "visitESSI: Done reading Gauss Points. Read " << ngauss[domain] << " GP coordinate values.\n\n";


            //Free up memory.
            delete [] index_to_coordinates;
            // delete [] m_number_of_gauss_points[domain];
            H5Dclose(id_gausspoints_coordinates);
            H5Sclose(id_coordinates_dataspace);
            H5Dclose(id_gausspoints_index_to_coordinates);
            H5Sclose(id_gausspoints_index_to_coordinates_dataspace);
            H5Dclose(id_number_of_gausspoints);
            H5Sclose(id_number_of_gausspoints_dataspace);

            //
            // Create a vtkUnstructuredGrid to contain the point cells.
            //
            m_gaussmesh_data[domain] = vtkUnstructuredGrid::New();
            m_gaussmesh_data[domain]->SetPoints(points);
            points->Delete();
            m_gaussmesh_data[domain]->Allocate(ngauss[domain]);
            vtkIdType onevertex;
            for (int i = 0; i < ngauss[domain]; ++i)
            {
                onevertex = i;
                m_gaussmesh_data[domain]->InsertNextCell(VTK_VERTEX, 1, &onevertex);
            }
        }
        m_gaussmesh_data[domain]->Register(NULL);
        return m_gaussmesh_data[domain];
    }

    return 0;
}


// ****************************************************************************
//  Method: avtvisitESSIFileFormat::GetVar
//
//  Purpose:
//      Gets a scalar variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      timestate  The index of the timestate.  If GetNTimesteps returned
//                 'N' time steps, this is guaranteed to be between 0 and N-1.
//      domain     The index of the domain.  If there are NDomains, this
//                 value is guaranteed to be between 0 and NDomains-1,
//                 regardless of block origin.
//      varname    The name of the variable requested.
//
//  Programmer: jaabell -- generated by xml2avt
//  Creation:   Thu May 15 11:22:33 PDT 2014
//
// ****************************************************************************

vtkDataArray *
avtvisitESSIFileFormat::GetVar(int timestate, int domain, const char *varname)
{
    // return 0;//YOU MUST IMPLEMENT THIS

    //
    // If you have a file format where variables don't apply (for example a
    // strictly polygonal format like the STL (Stereo Lithography) format,
    // then uncomment the code below.
    //
    // EXCEPTION1(InvalidVariableException, varname);
    //

    //
    // If you do have a scalar variable, here is some code that may be helpful.
    openSubdomainNumber(domain);

    int ntuples; // this is the number of entries in the variable.
    vtkIntArray *rv;
    GO_HERE << "GetVar(" << timestate << ", " << domain << ", " << varname << ")\n";
    if (strcmp(varname, "Node Tag") == 0)
    {
        // GO_HERE << "Getting Node tag\n";
        rv = vtkIntArray::New();
        ntuples = nnodes[domain];
        rv->SetNumberOfTuples(ntuples);
        if (m_pointnumbers2tags[domain])
        {
            for (int i = 0 ; i < ntuples ; i++)
            {
                // GO_HERE << "point = " << i << ",  tag = " << m_pointnumbers2tags[domain][i] << ", nnodes = " << nnodes << endl;
                rv->SetTuple1(i, m_pointnumbers2tags[domain][i]);  // you must determine value for ith entry.
            }
        }
        else
        {
            cerr << "avtvisitESSIFileFormat::GetVar() - m_pointnumbers2tags[domain] not set\n";
        }
    }
    else if (strcmp(varname, "Element Tag") == 0)
    {
        // GO_HERE << "Getting Node tag\n";
        rv = vtkIntArray::New();
        ntuples = ncells[domain];
        rv->SetNumberOfTuples(ntuples);
        if (m_pointnumbers2tags[domain])
        {
            for (int i = 0 ; i < ntuples ; i++)
            {
                // GO_HERE << "point = " << i << ",  tag = " << m_pointnumbers2tags[domain][i] << ", nnodes = " << nnodes << endl;
                rv->SetTuple1(i, m_cellnumbers2tags[domain][i]);  // you must determine value for ith entry.
            }
        }
        else
        {
            EXCEPTION1(InvalidVariableException, varname);
            cerr << "avtvisitESSIFileFormat::GetVar() - m_pointnumbers2tags[domain] not set\n";
        }
    }
    else if (strcmp(varname, "Element Partition") == 0)
    {
        // GO_HERE << "Getting Node tag\n";


        // hid_t id_partition           = H5Dopen2(id_file, "/Model/Elements/Partition", H5P_DEFAULT);
        // if (id_partition > 0)
        // {
        // hid_t id_partition_dataspace = H5Dget_space(id_partition);
        // hsize_t partition_nvals = H5Sget_simple_extent_npoints(id_partition_dataspace);
        // //Get the index to coordinates
        // int *partition = new int[partition_nvals];
        // if (partition)
        // {
        //     herr_t status = H5Dread(id_partition,
        //                             H5T_NATIVE_INT,
        //                             H5S_ALL,
        //                             id_partition_dataspace,
        //                             H5P_DEFAULT,
        //                             partition);
        // }
        // else
        // {
        //     cerr << "Ran out of memory getting partition. \n";
        //     return 0;
        // }
        // H5Sclose(id_partition_dataspace);
        // H5Dclose(id_partition);

        // GO_HERE << "ncells[domain] = " << ncells[domain] << endl;
        rv = vtkIntArray::New();
        rv->SetNumberOfTuples(ncells[domain]);
        int cell_number = 0;
        for (int ii = 0 ; ii < ncells[domain] ; ii++)
        {
            // cell_number = m_tags2cellnumbers[domain][ii];
            // GO_HERE << "cell_number = " << cell_number << ",  tag = " << tag << ", partition = "<< partition[tag] << endl;
            // if (cell_number >= 0)
            // {
            rv->SetTuple1(cell_number++, domain + 1);
            // }
        }
        // delete [] partition;
        // partition = 0;
        // }
        // else
        // {
        //     EXCEPTION1(InvalidVariableException, varname);
        //     cerr << "avtvisitESSIFileFormat::GetVar() - Element Partition not set\n";
        //     return 0;
        // }
    }
    else if (strcmp(varname, "Element Type") == 0)
    {
        // GO_HERE << "Getting Node tag\n";


        hid_t id_element_type           = H5Dopen2(id_file, "/Model/Elements/Class_Tags", H5P_DEFAULT);
        if (id_element_type > 0)
        {
            hid_t id_element_type_dataspace = H5Dget_space(id_element_type);
            hsize_t element_type_nvals = H5Sget_simple_extent_npoints(id_element_type_dataspace);
            //Get the index to coordinates
            int *element_type = new int[element_type_nvals];
            if (element_type)
            {
                herr_t status = H5Dread(id_element_type,
                                        H5T_NATIVE_INT,
                                        H5S_ALL,
                                        id_element_type_dataspace,
                                        H5P_DEFAULT,
                                        element_type);
            }
            else
            {
                cerr << "Ran out of memory getting element_type. \n";
                return 0;
            }
            H5Sclose(id_element_type_dataspace);
            H5Dclose(id_element_type);

            // GO_HERE << "ncells[domain] = " << ncells[domain] << endl;
            rv = vtkIntArray::New();
            rv->SetNumberOfTuples(ncells[domain]);
            int cell_number;
            for (int tag = 0 ; tag < element_type_nvals ; tag++)
            {
                cell_number = m_tags2cellnumbers[domain][tag];
                // GO_HERE << "cell_number = " << cell_number << ",  tag = " << tag << ", element_type = "<< element_type[tag] << endl;
                if (cell_number >= 0)
                {
                    rv->SetTuple1(cell_number, element_type[tag]);
                }
            }
            delete [] element_type;
            element_type = 0;
        }
    }

    else if (strcmp(varname, "8 Node Brick Update Time") == 0)
    {
//////////////////////////////////
//////////////////////////////////
//////////////////////////////////
//////////////////////////////////
//////////////////////////////////
//////////////////////////////////
//////////////////////////////////
        GO_HERE << "visitESSI: 8 Node Brick Update Time. \n\n";


// First get the types
        rv = 0;
        hid_t id_element_type           = H5Dopen2(id_file, "/Model/Elements/Class_Tags", H5P_DEFAULT);
        if (id_element_type > 0)
        {
            hid_t id_element_type_dataspace = H5Dget_space(id_element_type);
            hsize_t element_type_nvals = H5Sget_simple_extent_npoints(id_element_type_dataspace);
            int *element_type = new int[element_type_nvals];
            //Get the index to coordinates
            if (element_type)
            {
                herr_t status = H5Dread(id_element_type,
                                        H5T_NATIVE_INT,
                                        H5S_ALL,
                                        id_element_type_dataspace,
                                        H5P_DEFAULT,
                                        element_type);
            }
            else
            {
                cerr << "Ran out of memory getting element_type. \n";
                return 0;
            }
            H5Sclose(id_element_type_dataspace);
            H5Dclose(id_element_type);




            int n_8nodebrick = 0;
            for (int i = 0; i < element_type_nvals; i++)
            {
                if (element_type[i] == EightNodeBrickLT)
                {
                    n_8nodebrick ++;
                }
            }
            GO_HERE << "Counted " << n_8nodebrick << " 8NodeBrickLTs" << endl;

            // int ncomps = 3;  // This is the rank of the vector - typically 2 or 3.
            int ntuples = ncells[domain]; // this is the number of entries in the variable.
            int ucomps = 1;



            // Read output index
            hid_t id_elements_index_to_outputs = H5Dopen2(id_file, "/Model/Elements/Index_to_Outputs", H5P_DEFAULT);
            hid_t id_elements_index_to_outputs_dataspace = H5Dget_space(id_elements_index_to_outputs);
            hsize_t id_elements_index_to_outputs_nvals  = H5Sget_simple_extent_npoints(id_elements_index_to_outputs_dataspace);
            int *index_to_outputs  = new int[id_elements_index_to_outputs_nvals];
            H5Dread(id_elements_index_to_outputs, H5T_NATIVE_INT, H5S_ALL   , id_elements_index_to_outputs_dataspace, H5P_DEFAULT,
                    index_to_outputs);
            H5Dclose(id_elements_index_to_outputs);
            H5Sclose(id_elements_index_to_outputs_dataspace);


            // Read output
            hid_t id_elements_outputs = H5Dopen2(id_file, "/Model/Elements/Outputs", H5P_DEFAULT);
            hid_t id_elements_outputs_dataspace = H5Dget_space(id_elements_outputs);
            int elements_outputs_ndims = H5Sget_simple_extent_ndims(id_elements_outputs_dataspace);
            hsize_t dims[elements_outputs_ndims];
            hsize_t maxdims[elements_outputs_ndims];
            H5Sget_simple_extent_dims(id_elements_outputs_dataspace, dims, maxdims );


            //Create description of data in memory
            hsize_t datadims[1] = {dims[0]};
            hid_t memspace  = H5Screate_simple(1, datadims, datadims);


            //Try to get all the outputs (from all elements) now
            float *outputs = new float[dims[0]];

            const hsize_t start[2] = {0, timestate};
            const hsize_t stride[2] = {1, 1};
            const hsize_t count[2] = {dims[0], 1};
            const hsize_t block[2] = {1, 1};

            H5Sselect_hyperslab( id_elements_outputs_dataspace, H5S_SELECT_SET, start, stride, count, block );
            H5Dread(id_elements_outputs, H5T_NATIVE_FLOAT, memspace   , id_elements_outputs_dataspace, H5P_DEFAULT,
                    outputs);

            H5Dclose(id_elements_outputs);
            H5Sclose(id_elements_outputs_dataspace);
            H5Sclose(memspace);

            GO_HERE << "Read output vector" << endl;

            vtkFloatArray *rv = vtkFloatArray::New();

            // rv->SetNumberOfComponents(ucomps);
            rv->SetNumberOfTuples(ntuples);



            // float *one_entry = new float[ucomps];
            int gptag = 0;
            float maxstress = 0;
            float minstress;
            for (int tag = 1 ; tag < ncells[domain] ; tag++)
            {
                if (element_type[tag] == EightNodeBrickLT)
                {
                    int pos = index_to_outputs[tag];
                    float s = outputs[pos + 18 * 8] ; // 18 is the number of outputs per gauss-point first 6 are strains, next 6 are plastic strains and final 6 are stresses (hence the +12)
                    // GO_HERE << "tag = " << tag << ", t = " << s << ", gptag = " << gptag << endl;
                    rv->SetTuple1(gptag, s);
                }
                else
                {
                    rv->SetTuple1(gptag, 0);
                }

                // rv->SetTuple1(gptag, s);
                gptag++;
            }

            // delete [] one_entry;
            delete [] index_to_outputs;
            delete [] outputs;
            delete [] element_type;

            return rv;
        }
        return rv;
        //////////////////////////////////
        //////////////////////////////////
        //////////////////////////////////
        //////////////////////////////////
        //////////////////////////////////
        //////////////////////////////////
        ////////////////////////////////////////////
    }
    else
    {
        EXCEPTION1(InvalidVariableException, varname);
        cerr << "avtvisitESSIFileFormat::GetVar() - Element Partition not set\n";
        return 0;
    }
    return rv;
}



// ****************************************************************************
//  Method: avtvisitESSIFileFormat::GetVectorVar
//
//  Purpose:
//      Gets a vector variable associated with this file.  Although VTK has
//      support for many different types, the best bet is vtkFloatArray, since
//      that is supported everywhere through VisIt.
//
//  Arguments:
//      timestate  The index of the timestate.  If GetNTimesteps returned
//                 'N' time steps, this is guaranteed to be between 0 and N-1.
//      domain     The index of the domain.  If there are NDomains, this
//                 value is guaranteed to be between 0 and NDomains-1,
//                 regardless of block origin.
//      varname    The name of the variable requested.
//
//  Programmer: jaabell -- generated by xml2avt
//  Creation:   Thu May 15 11:22:33 PDT 2014
//
// ****************************************************************************

vtkDataArray *
avtvisitESSIFileFormat::GetVectorVar(int timestate, int domain, const char *varname)
{
    GO_HERE << "visitESSI: Trying to get " << varname << " at t = " << timestate << " on domain " << domain << " \n\n";


    openSubdomainNumber(domain);


    if (strcmp(varname, "Generalized Displacements") == 0)
    {
        // GO_HERE << "visitESSI: Getting generalized displacements. \n\n";
        int ncomps = 3;  // This is the rank of the vector - typically 2 or 3.
        int ntuples = nnodes[domain]; // this is the number of entries in the variable.
        int ucomps = 3;


        vtkFloatArray *rv = vtkFloatArray::New();
        rv->SetNumberOfComponents(ucomps);
        rv->SetNumberOfTuples(ntuples);

        //Get the  connectivity
        hid_t id_nodes_index_to_output = H5Dopen2(id_file, "/Model/Nodes/Index_to_Generalized_Displacements", H5P_DEFAULT);
        hid_t id_nodes_index_to_output_dataspace = H5Dget_space(id_nodes_index_to_output);
        hsize_t id_nodes_index_to_output_nvals  = H5Sget_simple_extent_npoints(id_nodes_index_to_output_dataspace);
        int *index_to_output  = new int[id_nodes_index_to_output_nvals];
        H5Dread(id_nodes_index_to_output, H5T_NATIVE_INT, H5S_ALL   , id_nodes_index_to_output_dataspace, H5P_DEFAULT,
                index_to_output);

        H5Dclose(id_nodes_index_to_output);
        H5Sclose(id_nodes_index_to_output_dataspace);



        //Open up displacements for reading
        hid_t id_nodes_displacements = H5Dopen2(id_file, "/Model/Nodes/Generalized_Displacements", H5P_DEFAULT);
        hid_t id_nodes_displacements_dataspace = H5Dget_space(id_nodes_displacements);
        int node_displacements_ndims = H5Sget_simple_extent_ndims(id_nodes_displacements_dataspace);
        hsize_t dims[node_displacements_ndims];
        hsize_t maxdims[node_displacements_ndims];
        H5Sget_simple_extent_dims(id_nodes_displacements_dataspace, dims, maxdims );


        //Create description of data in memory
        hsize_t datadims[1] = {dims[0]};
        hid_t memspace  = H5Screate_simple(1, datadims, datadims);

        // GO_HERE << "dims[0] = " << dims[0] << endl;

        //Try to get all the displacements now
        float *displacements = new float[dims[0]];

        const hsize_t start[2] = {0, timestate};
        const hsize_t stride[2] = {1, 1};
        const hsize_t count[2] = {dims[0], 1};
        const hsize_t block[2] = {1, 1};

        H5Sselect_hyperslab( id_nodes_displacements_dataspace, H5S_SELECT_SET, start, stride, count, block );
        H5Dread(id_nodes_displacements, H5T_NATIVE_FLOAT, memspace   , id_nodes_displacements_dataspace, H5P_DEFAULT,
                displacements);

        //Creanup
        H5Dclose(id_nodes_displacements);
        H5Sclose(id_nodes_displacements_dataspace);
        H5Sclose(memspace);

        // GO_HERE << "Writing\n";

        //Write the data to VTK
        float *one_entry = new float[ucomps];
        float *d = displacements;
        for (int i = 0 ; i < ntuples ; i++)
        {
            one_entry[0] = *(d++);
            one_entry[1] = *(d++);
            one_entry[2] = *(d++);

            // GO_HERE << "d[" << i << "] = (" << one_entry[0] << ", " << one_entry[1] << ", " << one_entry[2] << ")";

            d += m_number_of_dofs[domain][m_pointnumbers2tags[domain][i]] - 3;
            // GO_HERE << ".";
            rv->SetTuple(i, one_entry);
            // GO_HERE << ".\n";
        }

        delete [] one_entry;
        delete [] index_to_output;
        delete [] displacements;



        return rv;
    }

    // =============================================================================================
    // =============================================================================================
    // =============================================================================================
    // =============================================================================================
    // =============================================================================================
    // =============================================================================================
    // =============================================================================================
    // =============================================================================================
    // =============================================================================================

    else if (strcmp(varname, "Stress") == 0 | strcmp(varname, "Strain") == 0 |  strcmp(varname, "Plastic Strain") == 0 )
    {
        int vartype = 0;
        if (strcmp(varname, "Plastic Strain") == 0 )
        {
            vartype = 1;
        }
        if (strcmp(varname, "Stress") == 0 )
        {
            vartype = 2;
        }
        GO_HERE << "visitESSI: Getting stress form " << ngauss[domain] << " GPs on " << ncells[domain] << " elements \n\n";
        if (H5Lexists(id_file, "/Model/Elements/Outputs", H5P_DEFAULT) != FALSE)
        {
            int ncomps = 3;  // This is the rank of the vector - typically 2 or 3.
            int ntuples = ngauss[domain]; // this is the number of entries in the variable.
            int ucomps = 9;


            vtkFloatArray *rv = vtkFloatArray::New();
            rv->SetNumberOfComponents(ucomps);
            rv->SetNumberOfTuples(ntuples);


            // Read output index
            hid_t id_elements_index_to_outputs = H5Dopen2(id_file, "/Model/Elements/Index_to_Outputs", H5P_DEFAULT);
            hid_t id_elements_index_to_outputs_dataspace = H5Dget_space(id_elements_index_to_outputs);
            hsize_t id_elements_index_to_outputs_nvals  = H5Sget_simple_extent_npoints(id_elements_index_to_outputs_dataspace);
            int *index_to_outputs  = new int[id_elements_index_to_outputs_nvals];
            H5Dread(id_elements_index_to_outputs, H5T_NATIVE_INT, H5S_ALL   , id_elements_index_to_outputs_dataspace, H5P_DEFAULT,
                    index_to_outputs);
            H5Dclose(id_elements_index_to_outputs);
            H5Sclose(id_elements_index_to_outputs_dataspace);

            // Read output index
            hid_t id_elements_n_output_vals = H5Dopen2(id_file, "/Model/Elements/Number_of_Output_Fields", H5P_DEFAULT);
            hid_t id_elements_n_output_vals_dataspace = H5Dget_space(id_elements_n_output_vals);
            hsize_t id_elements_n_output_vals_nvals  = H5Sget_simple_extent_npoints(id_elements_n_output_vals_dataspace);
            int *n_output_vals  = new int[id_elements_n_output_vals_nvals];
            H5Dread(id_elements_n_output_vals, H5T_NATIVE_INT, H5S_ALL   , id_elements_n_output_vals_dataspace, H5P_DEFAULT,
                    n_output_vals);
            H5Dclose(id_elements_n_output_vals);
            H5Sclose(id_elements_n_output_vals_dataspace);

            // Read output
            hid_t id_elements_outputs = H5Dopen2(id_file, "/Model/Elements/Outputs", H5P_DEFAULT);
            hid_t id_elements_outputs_dataspace = H5Dget_space(id_elements_outputs);
            int elements_outputs_ndims = H5Sget_simple_extent_ndims(id_elements_outputs_dataspace);
            hsize_t dims[elements_outputs_ndims];
            hsize_t maxdims[elements_outputs_ndims];
            H5Sget_simple_extent_dims(id_elements_outputs_dataspace, dims, maxdims );


            //Create description of data in memory
            hsize_t datadims[1] = {dims[0]};
            hid_t memspace  = H5Screate_simple(1, datadims, datadims);


            //Try to get all the outputs (from all elements) now
            float *outputs = new float[dims[0]];

            const hsize_t start[2] = {0, timestate};
            const hsize_t stride[2] = {1, 1};
            const hsize_t count[2] = {dims[0], 1};
            const hsize_t block[2] = {1, 1};

            H5Sselect_hyperslab( id_elements_outputs_dataspace, H5S_SELECT_SET, start, stride, count, block );
            H5Dread(id_elements_outputs, H5T_NATIVE_FLOAT, memspace   , id_elements_outputs_dataspace, H5P_DEFAULT,
                    outputs);

            H5Dclose(id_elements_outputs);
            H5Sclose(id_elements_outputs_dataspace);
            H5Sclose(memspace);

            // GO_HERE << "ncells[domain] = " << ncells[domain] << endl;
            float *one_entry = new float[ucomps];
            int gptag = 0;
            int order[9] = { 0 , 3,  4 , 3, 1, 5, 4, 5, 2 }; // This converts 6 component symmetric stress to 9 component general tensor... matrix is filled row-wise.
            float maxstress = -std::numeric_limits<double>::infinity();
            float minstress = std::numeric_limits<double>::infinity();
            // for (int tag = 0 ; tag < ncells[domain] ; tag++)
            for (int tag = 0 ; tag < id_elements_index_to_outputs_nvals ; tag++)
            {
                int pos = index_to_outputs[tag];
                int number_of_gauss_point_for_this_element = m_number_of_gauss_points[domain][tag];

                for (int gp = 0; gp < number_of_gauss_point_for_this_element; gp++)
                {

                    if (n_output_vals[tag] <= 0)
                    {
                        for (int i = 0; i < 9; i++)
                        {
                            one_entry[i]  = 0.;
                        }
                        rv->SetTuple(gptag, one_entry);
                        gptag++;
                        continue;
                    }

                    // float *s = outputs[ pos + 18 * gp + 12]; // 18 is the number of outputs per gauss-point first 6 are strains, next 6 are plastic strains and final 6 are stresses (hence the +12)
                    float *s = outputs + pos + 18 * gp + 6 * vartype; // 18 is the number of outputs per gauss-point first 6 are strains, next 6 are plastic strains and final 6 are stresses (hence the +12)
                    for (int i = 0; i < 9; i++)
                    {
                        one_entry[i] = *(s + order[i]);
                        if (one_entry[i] > maxstress)
                        {
                            maxstress = one_entry[i];
                        }
                        else if (one_entry[i] < minstress)
                        {
                            minstress = one_entry[i];
                        }
                    }

                    rv->SetTuple(gptag, one_entry);
                    gptag++;
                }
            }

            GO_HERE << "gptag = " << gptag << endl;


            GO_HERE << "Max stress = " << maxstress << endl;
            GO_HERE << "Min stress = " << minstress << endl;


            delete [] one_entry;
            delete [] index_to_outputs;
            delete [] outputs;

            return rv;
        }
        else  // The dataset "/Model/Elements/Outputs" was not found. Skip!
        {
            GO_HERE << "The outputs dataset doesn't exist in this domain. Domain contains only elements that didn't produce output? Elegantly skipping!" << endl;
            return 0;
        }
    }
    else
    {
        GO_HERE << "visitESSI : Variable '" << varname <<  "' not available. \n\n";
        cerr << "visitESSI : Variable '" << varname <<  "' not available. \n\n";
    }
    return 0;
}






// Override this method in your reader
void
avtvisitESSIFileFormat::ActivateTimestep()
{
    initialize();
}




void avtvisitESSIFileFormat::initialize()
{
    if (!initialized)
    {
        bool okay = false;

        GO_HERE << "visitESSI : Opening : " << filename_string << "\n\n";
        id_file = H5Fopen( filename_string.c_str(), H5F_ACC_RDONLY, H5P_DEFAULT);
        GO_HERE << "Got id  to file : " << id_file << "\n\n";

        if (id_file >= 0)
        {
            okay = true;
        }

        if (!okay)
        {
            GO_HERE << "visitESSI : Could not open file.\n\n";
            EXCEPTION1(InvalidDBTypeException,
                       "The file could not be opened");
        }

        //Read number of time steps
        hid_t id_num_tsteps = H5Dopen2(id_file, "/Number_of_Time_Steps", H5P_DEFAULT);
        hid_t id_num_tsteps_dataspace = H5Dget_space(id_num_tsteps);
        H5Dread(id_num_tsteps, H5T_NATIVE_INT, H5S_ALL   , id_num_tsteps_dataspace, H5P_DEFAULT,
                &nsteps);
        H5Dclose(id_num_tsteps);
        H5Sclose(id_num_tsteps_dataspace);

        //Read number of elements
        // hid_t id_num_elements = H5Dopen2(id_file, "/Number_of_Elements", H5P_DEFAULT);
        // hid_t id_num_elements_dataspace = H5Dget_space(id_num_elements);
        // H5Dread(id_num_elements, H5T_NATIVE_INT, H5S_ALL   , id_num_elements_dataspace, H5P_DEFAULT,
        //         &ncells[domain]);
        // H5Dclose(id_num_elements);
        // H5Sclose(id_num_elements_dataspace);

        //Read number of nodes
        // hid_t id_num_nodes = H5Dopen2(id_file, "/Number_of_Nodes", H5P_DEFAULT);
        // hid_t id_num_nodes_dataspace = H5Dget_space(id_num_nodes);
        // H5Dread(id_num_nodes, H5T_NATIVE_INT, H5S_ALL   , id_num_nodes_dataspace, H5P_DEFAULT,
        //         &nnodes);
        // H5Dclose(id_num_nodes);
        // H5Sclose(id_num_nodes_dataspace);

        //Read number of processes used
        // Number_of_Processes_Used
        hid_t id_numprocs = H5Dopen2(id_file, "/Number_of_Processes_Used", H5P_DEFAULT);
        hid_t id_numprocs_dataspace = H5Dget_space(id_numprocs);
        H5Dread(id_numprocs, H5T_NATIVE_INT, H5S_ALL   , id_numprocs_dataspace, H5P_DEFAULT,
                &number_of_processes);
        H5Dclose(id_numprocs);
        H5Sclose(id_numprocs_dataspace);

        //Process_Number
        hid_t id_procnum = H5Dopen2(id_file, "/Process_Number", H5P_DEFAULT);
        hid_t id_procnum_dataspace = H5Dget_space(id_procnum);
        H5Dread(id_procnum, H5T_NATIVE_INT, H5S_ALL   , id_procnum_dataspace, H5P_DEFAULT,
                &process_number);
        H5Dclose(id_procnum);
        H5Sclose(id_procnum_dataspace);

        m_gauss_to_element_tag = new int*[number_of_processes];
        m_number_of_gauss_points = new int*[number_of_processes];
        m_number_of_dofs = new int*[number_of_processes];
        m_tags2pointnumbers = new int*[number_of_processes];
        m_pointnumbers2tags = new int*[number_of_processes];
        m_tags2cellnumbers = new int*[number_of_processes];
        m_cellnumbers2tags = new int*[number_of_processes];
        m_mainmesh_data = new vtkUnstructuredGrid*[number_of_processes];
        m_gaussmesh_data = new vtkUnstructuredGrid*[number_of_processes];

        for (int d = 0; d < number_of_processes ; d++)
        {
            GO_HERE << "Initializing arrays for domain : " << d << endl;
            m_gauss_to_element_tag[d] = NULL;
            m_number_of_gauss_points[d] = NULL;
            m_number_of_dofs[d] = NULL;
            m_tags2pointnumbers[d] = NULL;
            m_pointnumbers2tags[d] = NULL;
            m_tags2cellnumbers[d] = NULL;
            m_cellnumbers2tags[d] = NULL;
            m_mainmesh_data[d] = NULL;
            m_gaussmesh_data[d] = NULL;
        }


        GO_HERE << "Number of time-steps = " << nsteps << endl;
        // GO_HERE << "Number of nodes      = " << nnodes << endl;
        // GO_HERE << "Number of elements   = " << ncells[domain] << endl;
        GO_HERE << "Number of processes  = " << number_of_processes << endl;
        GO_HERE << "This process         = " << process_number << endl;

        PopulateTimeAndNSteps();

        initialized = true;
    }
}




void
avtvisitESSIFileFormat::GetTime(std::vector<double> &times)
{
    if (nsteps < 0)
    {
        PopulateTimeAndNSteps();
    }
    times = t;
    GO_HERE << "times = ";
    for (int i = 0; i < times.size(); i++)
    {
        GO_HERE << times[i] << endl;
    }
}

double
avtvisitESSIFileFormat::GetTime(int i)
{
    if (nsteps < 0)
    {
        PopulateTimeAndNSteps();
    }
    return t[i];
}



// ****************************************************************************
//  Method: avtEMSTDFileFormat::GetNTimesteps
//
//  Purpose:
//      Tells the rest of the code how many timesteps there are in this file.
//
//  Programmer: jaabell -- generated by xml2avt
//  Creation:   Fri May 9 11:32:38 PDT 2014
//
// ****************************************************************************


//IMPLEMENT ME!
int
avtvisitESSIFileFormat::GetNTimesteps(void)
{
    if (nsteps <= 0)
    {
        PopulateTimeAndNSteps();
    }
    return nsteps;
}



void avtvisitESSIFileFormat::PopulateTimeAndNSteps()
{
    if (nsteps < 0)
    {

        initialize();
        GO_HERE << "visitESSI : Getting time\n\n";
        //Get the time dimension
        hid_t id_time = H5Dopen2(id_file, "/time", H5P_DEFAULT);
        hid_t id_time_dataspace = H5Dget_space(id_time);
        hsize_t id_time_nvals  = H5Sget_simple_extent_npoints(id_time_dataspace);


        GO_HERE << "visitESSI : feioutput file contains " << id_time_nvals << " timesteps.\n\n";

        if (nsteps != id_time_nvals)
        {
            GO_HERE << "Something wrong nsteps != id_time_nvals  ( " << nsteps << " != " << id_time_nvals << ") \n\n";
        }
        // nsteps = id_time_nvals;

        double *vals = new double[nsteps] ;
        H5Dread(id_time, H5T_NATIVE_DOUBLE, H5S_ALL   , id_time_dataspace, H5P_DEFAULT,
                vals);

        // Store the times in the vector.
        for (int i = 0; i < nsteps; ++i)
        {
            t.push_back(vals[i]);
        }
        delete [] vals;
    }
}


void *
avtvisitESSIFileFormat::GetAuxiliaryData(const char *var,
        int domain, const char *type, void *,
        DestructorFunction & df)
{
    GO_HERE << "Auxiliary data requested: " << type << ", domain = " << domain << ", var = " << var << endl;
    void *retval = 0;
    if (strcmp(type, AUXILIARY_DATA_SPATIAL_EXTENTS) == 0)
    {
        GO_HERE << "Extents requested!\n";

        // Read the number of domains for the mesh.
        int ndoms = number_of_processes - 1;

        // Read the spatial extents for each domain of the
        // mesh. This information should be in a single
        // and should be available without having to
        // read the real data. The expected format for
        // the data in the spatialextents array is to
        // repeat the following pattern for each domain:
        // xmin, xmax, ymin, ymax, zmin, zmax.
        double *spatialextents = new double[ndoms * 6];

        //READ ndoms * 6 DOUBLE VALUES INTO spatialextents ARRAY.
        for (int d = 1; d <= ndoms; d++)
        {
            openSubdomainNumber(domain);
            hid_t id_model_bounds = H5Dopen2(id_file, "/Model/Model_Bounds", H5P_DEFAULT);
            hid_t id_model_bounds_dataspace = H5Dget_space(id_model_bounds);
            hsize_t id_model_bounds_nvals  = H5Sget_simple_extent_npoints(id_model_bounds_dataspace);


            // GO_HERE << "visitESSI : feioutput file contains " << id_model_bounds_nvals << " timesteps.\n\n";

            if (6 != id_model_bounds_nvals)
            {
                GO_HERE << "Something wrong 6 != id_model_bounds_nvals  ( 6 != " << id_model_bounds_nvals << ") \n\n";
            }
            // nsteps = id_time_nvals;

            // double *vals = new double[nsteps] ;
            H5Dread(id_model_bounds, H5T_NATIVE_DOUBLE, H5S_ALL   , id_model_bounds_dataspace, H5P_DEFAULT,
                    spatialextents + (d - 1) * 6);
        }

        // Create an interval tree
        avtIntervalTree *itree = new avtIntervalTree(ndoms, 3);
        double *extents = spatialextents;
        for (int dom = 0; dom < ndoms; ++dom)
        {
            itree->AddElement(dom, extents);
            extents += 6;
        }
        itree->Calculate(true);

        // Delete temporary array.
        delete [] spatialextents;

        // Set return values
        retval = (void *)itree;
        df = avtIntervalTree::Destruct;
    }
    return retval;
}


void
avtvisitESSIFileFormat::openSubdomainNumber(int domain)
{
    if ((id_file > 0) && (number_of_processes > 1) )
    {
        //Need to open another HDF5 file
        H5Fclose(id_file);
        std::string subdomain_filename = filename_string;

        // Determine the number of digits in the total number of processes
        int number = number_of_processes;
        int digits = 0;
        if (number < 0)
        {
            digits = 1;    // remove this line if '-' counts as a digit
        }
        while (number)
        {
            number /= 10;
            digits++;
        }

        std::stringstream ss;
        ss << ".";
        ss << setfill('0') << setw(digits) << domain + 1;

        size_t f = subdomain_filename.find(".feioutput");
        subdomain_filename.replace(f, std::string(".feioutput").length(), ss.str());
        subdomain_filename += ".feioutput";

        GO_HERE << " Opening : " << subdomain_filename << endl;
        id_file = H5Fopen( subdomain_filename.c_str(), H5F_ACC_RDONLY, H5P_DEFAULT);

        //Read number of elements
        hid_t id_num_elements = H5Dopen2(id_file, "/Number_of_Elements", H5P_DEFAULT);
        hid_t id_num_elements_dataspace = H5Dget_space(id_num_elements);
        H5Dread(id_num_elements, H5T_NATIVE_INT, H5S_ALL   , id_num_elements_dataspace, H5P_DEFAULT,
                &ncells[domain]);
        H5Dclose(id_num_elements);
        H5Sclose(id_num_elements_dataspace);

        //Read number of nodes
        hid_t id_num_nodes = H5Dopen2(id_file, "/Number_of_Nodes", H5P_DEFAULT);
        hid_t id_num_nodes_dataspace = H5Dget_space(id_num_nodes);
        H5Dread(id_num_nodes, H5T_NATIVE_INT, H5S_ALL   , id_num_nodes_dataspace, H5P_DEFAULT,
                &nnodes[domain]);
        H5Dclose(id_num_nodes);
        H5Sclose(id_num_nodes_dataspace);
    }
}